from collections import deque

def last_card(N):
    # 큐 초기화 및 카드 넣기
    queue = deque(range(1, N + 1))
    
    # 카드가 한 장 남을 때까지 반복
    while len(queue) > 1:
        queue.popleft()      # 제일 위에 있는 카드를 버림
        queue.append(queue.popleft())  # 제일 위에 있는 카드를 제일 아래로 이동
    
    # 마지막으로 남은 카드 출력
    return queue[0]

# 입력 받기
N = int(input().strip())
print(last_card(N))

"""
1. queue.popleft() 메서드는 제일 위에 있는 카드를 큐에서 제거하면서 그 카드를 반환합니다. 
2. deque는 range뿐만 아니라 list도 인수로 받을 수 있습니다. deque는 iterable한 객체라면 무엇이든 인수로 받을 수 있습니다
"""





def josephus_sequence(N, K):
    people = list(range(1, N + 1))  # 1부터 N까지의 사람들
    result = []  # 요세푸스 순열을 저장할 리스트
    index = 0  # 시작 인덱스

    while people:
        index = (index + K - 1) % len(people)  # 제거할 사람의 인덱스 계산(*)
        result.append(people.pop(index))  # 제거된 사람을 결과 리스트에 추가

    return result

# 입력 받기
N, K = map(int, input().strip().split())
result = josephus_sequence(N, K)
print("<" + ", ".join(map(str, result)) + ">")

"""
1. pop 메서드는 지정된 인덱스의 요소를 반환하고, 동시에 그 요소를 리스트에서 제거합니다.
2. 위 식(*)은 현재 인덱스에서 K번째 사람의 위치를 계산하고, 리스트의 길이를 넘지 않도록 하기 위해 모듈러 연산 (%)을 사용합니다. 
"""





from collections import deque
import sys
input = sys.stdin.read

def process_commands(commands):
    deq = deque()
    results = []
    for command in commands:
        if command[0] == '1':
            deq.appendleft(int(command[2:]))
        elif command[0] == '2':
            deq.append(int(command[2:]))
        elif command[0] == '3':
            if deq:
                results.append(deq.popleft())
            else:
                results.append(-1)
        elif command[0] == '4':
            if deq:
                results.append(deq.pop())
            else:
                results.append(-1)
        elif command[0] == '5':
            results.append(len(deq))
        elif command[0] == '6':
            results.append(1 if not deq else 0)
        elif command[0] == '7':
            if deq:
                results.append(deq[0])
            else:
                results.append(-1)
        elif command[0] == '8':
            if deq:
                results.append(deq[-1])
            else:
                results.append(-1)
    return results

# 입력 받기
input_data = input().strip().split('\n')
N = int(input_data[0])
commands = input_data[1:]

# 명령 처리 및 결과 출력
results = process_commands(commands)
for result in results:
    print(result)

"""
1. deq = deque()는 덱(deque) 객체를 초기화하는 역할을 합니다. 이를 통해 deq라는 이름의 비어 있는 덱을 생성합니다. 이 덱을 사용하여 앞으로 주어진 명령을 처리할 수 있습니다.
2. append와 pop 메서드는 기본적으로 덱의 가장 뒤쪽에 있는 요소에 대해 수행됩니다. 그래서 덱의 앞쪽에 요소를 추가하거나 제거할 때는 appendleft와 popleft 메서드를 사용합니다. 
3. command[2]를 사용하는 대신 command[2:]를 사용하는 이유는 숫자가 한 자리 숫자일 때는 문제가 없지만, 두 자리 이상의 숫자를 처리할 때 필요하기 때문입니다. 
"""





from collections import deque

def balloon_pop_order(N, balloon_values):
    balloons = deque(enumerate(balloon_values, 1))  # (풍선 번호, 종이 값) 쌍으로 묶기
    result = []

    while balloons:
        idx, val = balloons.popleft()  # 풍선 터뜨리기
        result.append(idx)
        
        if balloons:
            # 이동할 값에 따라 deque를 회전시킴
            if val > 0:
                balloons.rotate(-(val - 1))  # 양수인 경우 오른쪽으로 회전
            else:
                balloons.rotate(-val)  # 음수인 경우 왼쪽으로 회전

    return result

# 입력 받기
N = int(input().strip())
balloon_values = list(map(int, input().strip().split()))

# 결과 계산 및 출력
result = balloon_pop_order(N, balloon_values)
print(" ".join(map(str, result)))

"""
1. 예제 입력이 5와 3 2 1 -3 -1일 경우 :
balloon_values = [3, 2, 1, -3, -1] / 
enumerate(balloon_values, 1) = (1, 3), (2, 2), (3, 1), (4, -3), (5, -1) # balloon_values 리스트의 각 요소에 대해 1부터 시작하는 인덱스를 부여하는 함수 /
balloon = deque([(1, 3), (2, 2), (3, 1), (4, -3), (5, -1)]) #  각 풍선의 번호와 그 안에 적힌 값을 쌍으로 가지는 deque 객체

2. while문을 1번만 실행할 때
deque([(2, 2), (3, 1), (4, -3), (5, -1)])에서 balloons.rotate(-(val - 1))이므로        # 여기서 val은 3, 따라서 rotate(-2)
오른쪽으로 2번 회전시키면, balloons의 상태는 deque([(4, -3), (5, -1), (2, 2), (3, 1)])

3. rotate는 기본적으로 양의 인수에 대해 반시계방향이라고 생각하면 된다.
"""






from collections import deque
import sys
input = sys.stdin.read

def queuestack_simulation(N, A, B, M, C):
    # 각 자료구조를 초기화
    data_structures = []
    for i in range(N):
        if A[i] == 0:  # 큐인 경우
            dq = deque()
            dq.append(B[i])
            data_structures.append(dq)
        else:  # 스택인 경우
            stk = [B[i]]
            data_structures.append(stk)
    
    results = []
    
    for x in C:
        current = x
        for i in range(N):
            if A[i] == 0:  # 큐인 경우에만 처리
                data_structures[i].append(current)
                current = data_structures[i].popleft()
        results.append(current)
    
    return results

# 입력 처리
data = input().split()
N = int(data[0])
A = list(map(int, data[1:N+1]))
B = list(map(int, data[N+1:2*N+1]))
M = int(data[2*N+1])
C = list(map(int, data[2*N+2:]))

# 함수 호출 및 결과 출력
results = queuestack_simulation(N, A, B, M, C)
print(" ".join(map(str, results)))

"""
간단하게 한 버전
"""
import sys
input = sys.stdin.read

def queuestack_simulation(N, A, B, M, C):
    # 각 자료구조를 초기화
    data_structures = [[B[i]] for i in range(N)]
    
    results = []
    
    for x in C:
        current = x
        for i in range(N):
            if A[i] == 0:  # 큐인 경우에만 처리
                data_structures[i].append(current)
                current = data_structures[i].pop(0)  # 큐에서는 앞의 요소를 제거
        results.append(current)
    
    return results

# 입력 처리
data = input().split()
N = int(data[0])
A = list(map(int, data[1:N+1]))
B = list(map(int, data[N+1:2*N+1]))
M = int(data[2*N+1])
C = list(map(int, data[2*N+2:]))

# 함수 호출 및 결과 출력
results = queuestack_simulation(N, A, B, M, C)
print(" ".join(map(str, results)))

"""
☆☆☆ 시간초과로 계속 나가리 ☆☆☆
"""





