from itertools import permutations

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split()
    N = int(data[0])
    M = int(data[1])
    
    nums = list(range(1, N + 1))
    perms = permutations(nums, M)
    
    # Convert to list to print all permutations at once, ë¬¸ì œ í’€ì´ì—ëŠ” ë¶ˆí•„ìš”
    perms_list = list(perms)
    print(perms_list)  # [(1, 2, 3, 4), (1, 2, 4, 3), ... , (4, 3, 1, 2), (4, 3, 2, 1)]
    
    for perm in perms_list:
        print(' '.join(map(str, perm)))

if __name__ == "__main__":
    main()






from itertools import combinations

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split()
    N = int(data[0])
    M = int(data[1])
    
    nums = list(range(1, N + 1))
    combs = combinations(nums, M)
    
    for comb in combs:
        print(' '.join(map(str, comb)))

if __name__ == "__main__":
    main()





# ì£¼ì–´ì§„ iterableì˜ ë°ì¹´ë¥´íŠ¸ ê³±ì„ ê³„ì‚°í•˜ì—¬ ëª¨ë“  ê°€ëŠ¥í•œ ì¡°í•©ì„ ìƒì„±
from itertools import product

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split()
    N = int(data[0])
    M = int(data[1])
    
    nums = list(range(1, N + 1))
    prod = product(nums, repeat=M)
    
    for p in prod:
        print(' '.join(map(str, p)))

if __name__ == "__main__":
    main()





# ì£¼ì–´ì§„ iterableì—ì„œ ì¤‘ë³µì„ í—ˆìš©í•˜ëŠ” ì¡°í•©
from itertools import combinations_with_replacement

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split()
    N = int(data[0])
    M = int(data[1])
    
    nums = list(range(1, N + 1))
    combs = combinations_with_replacement(nums, M)
    
    for comb in combs:
        print(' '.join(map(str, comb)))

if __name__ == "__main__":
    main()





def solve_n_queens(n):
    def backtrack(row):
        if row == n:
            return 1
        count = 0
        for col in range(n):
            if not (cols[col] or diag1[row - col + n - 1] or diag2[row + col]):
                cols[col] = diag1[row - col + n - 1] = diag2[row + col] = True
                count += backtrack(row + 1)
                cols[col] = diag1[row - col + n - 1] = diag2[row + col] = False
        return count
    
    cols = [False] * n
    diag1 = [False] * (2 * n - 1)
    diag2 = [False] * (2 * n - 1)
    return backtrack(0)

def main():
    import sys
    input = sys.stdin.read
    N = int(input().strip())
    print(solve_n_queens(N))

if __name__ == "__main__":
    main()

"""
cols[col]: col ì—´ì— í€¸ì´ ìˆëŠ”ì§€ ì—¬ë¶€.
diag1[row - col]: ì¢Œìƒí–¥ ëŒ€ê°ì„ ì— í€¸ì´ ìˆëŠ”ì§€ ì—¬ë¶€.
diag2[row + col]: ìš°ìƒí–¥ ëŒ€ê°ì„ ì— í€¸ì´ ìˆëŠ”ì§€ ì—¬ë¶€.

ìš”ì•½
backtrack í•¨ìˆ˜ëŠ” ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œë˜ë©´ì„œ ê° í–‰(row)ì— í€¸ì„ ë†“ê³ , ê°€ëŠ¥í•œ ê²½ìš°ì˜ ìˆ˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤. 
countëŠ” ê° ì¬ê·€ í˜¸ì¶œì—ì„œ ê°€ëŠ¥í•œ ë°°ì¹˜ì˜ ê°œìˆ˜ë¥¼ ëˆ„ì í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.

solve_n_queens(8)ì€ 8x8 ì²´ìŠ¤íŒì—ì„œ 8ê°œì˜ í€¸ì„ ë†“ëŠ” ëª¨ë“  ê°€ëŠ¥í•œ ë°©ë²•ì„ ì°¾ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
backtrack(row) í•¨ìˆ˜ëŠ” í˜„ì¬ í–‰ì— í€¸ì„ ë†“ê³ , ì¬ê·€ì ìœ¼ë¡œ ë‹¤ìŒ í–‰ìœ¼ë¡œ ì´ë™í•˜ì—¬ ëª¨ë“  í€¸ì„ ë°°ì¹˜í•˜ëŠ” ë°©ë²•ì„ ì°¾ìŠµë‹ˆë‹¤.
cols, diag1, diag2 ë°°ì—´ì„ ì‚¬ìš©í•˜ì—¬ ì—´ê³¼ ëŒ€ê°ì„ ì— í€¸ì´ ìˆëŠ”ì§€ ë¹ ë¥´ê²Œ ì²´í¬í•©ë‹ˆë‹¤.
ëª¨ë“  í€¸ì„ ë°°ì¹˜í•˜ëŠ” ê²½ìš° ì¹´ìš´íŠ¸ë¥¼ ì¦ê°€ì‹œí‚¤ê³ , ë°±íŠ¸ë˜í‚¹ì„ í†µí•´ ë‹¤ë¥¸ ê°€ëŠ¥í•œ ë°°ì¹˜ë¥¼ íƒìƒ‰í•©ë‹ˆë‹¤.

1. ì²« ë²ˆì§¸ í–‰(row = 0)ì—ì„œ í€¸ì„ ë°°ì¹˜:
ì˜ˆë¥¼ ë“¤ì–´, col = 0ì— í€¸ì„ ë†“ìŠµë‹ˆë‹¤.
ìƒíƒœë¥¼ ê°±ì‹ : cols[0] = True, diag1[0 - 0 + 7] = True, diag2[0 + 0] = True
backtrack(1)ì„ í˜¸ì¶œí•˜ì—¬ ë‘ ë²ˆì§¸ í–‰ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.

2. ë‘ ë²ˆì§¸ í–‰(row = 1)ì—ì„œ í€¸ì„ ë°°ì¹˜:
ì˜ˆë¥¼ ë“¤ì–´, col = 2ì— í€¸ì„ ë†“ìŠµë‹ˆë‹¤.
ìƒíƒœë¥¼ ê°±ì‹ : cols[2] = True, diag1[1 - 2 + 7] = True, diag2[1 + 2] = True
backtrack(2)ì„ í˜¸ì¶œí•˜ì—¬ ì„¸ ë²ˆì§¸ í–‰ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.

3. ì¬ê·€ í˜¸ì¶œì´ ëë‚œ í›„ ìƒíƒœë¥¼ ë³µêµ¬:
backtrack(2)ì´ ì¢…ë£Œëœ í›„, col = 2ì— ë†“ì€ í€¸ì„ ì œê±°í•©ë‹ˆë‹¤.
ìƒíƒœë¥¼ ë³µêµ¬: cols[2] = False, diag1[1 - 2 + 7] = False, diag2[1 + 2] = False
ì´í›„ ë‹¤ë¥¸ ì—´(col = 3 ë“±)ì— í€¸ì„ ë†“ëŠ” ê²ƒì„ ì‹œë„í•©ë‹ˆë‹¤.

ì´ ê³¼ì •ì„ ë°˜ë³µí•˜ì—¬ ëª¨ë“  ê°€ëŠ¥í•œ í€¸ ë°°ì¹˜ë¥¼ íƒìƒ‰í•˜ê³ , ê° ê²½ìš°ì˜ ìˆ˜ë¥¼ countì— ëˆ„ì í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.

ì¬ê·€ í˜¸ì¶œì´ ëë‚œ í›„ ìƒíƒœë¥¼ ë³µêµ¬í•˜ëŠ” ì´ìœ ëŠ” ë°±íŠ¸ë˜í‚¹ ì•Œê³ ë¦¬ì¦˜ì˜ í•µì‹¬ì…ë‹ˆë‹¤. 
ë°±íŠ¸ë˜í‚¹ì€ í•´ë¥¼ ì°¾ëŠ” ë„ì¤‘ì— ê°€ëŠ¥í•œ ëª¨ë“  ê²½ìš°ë¥¼ íƒìƒ‰í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì—, í•œ ê²½ë¡œë¥¼ íƒìƒ‰í•œ í›„ ë‹¤ë¥¸ ê²½ë¡œë¥¼ íƒìƒ‰í•  ìˆ˜ ìˆë„ë¡
ìƒíƒœë¥¼ ì›ë˜ëŒ€ë¡œ ëŒë ¤ë†“ì•„ì•¼ í•©ë‹ˆë‹¤. 
"""





# ì‹œê°„ì´ˆê³¼
def solve_sudoku(board):
    rows = [set(range(1, 10)) for _ in range(9)]
    cols = [set(range(1, 10)) for _ in range(9)]
    boxes = [set(range(1, 10)) for _ in range(9)]
    empty_cells = []

    for r in range(9):
        for c in range(9):
            if board[r][c] == 0:
                empty_cells.append((r, c))
            else:
                rows[r].remove(board[r][c])
                cols[c].remove(board[r][c])
                boxes[(r // 3) * 3 + (c // 3)].remove(board[r][c])

    def backtrack(index):
        if index == len(empty_cells):
            return True               # ëª¨ë“  ë¹ˆ ì¹¸ì„ ì±„ìš´ ê²½ìš° Trueë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
        r, c = empty_cells[index]
        box_index = (r // 3) * 3 + (c // 3)
        for num in rows[r] & cols[c] & boxes[box_index]: # í˜„ì¬ í–‰, ì—´, 3x3 ë°•ìŠ¤ì—ì„œ ê°€ëŠ¥í•œ ìˆ«ìì˜ êµì§‘í•©ì„ êµ¬í•œ
            board[r][c] = num                            # ìˆ«ìë¥¼ ë°°ì¹˜í•˜ê³  ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸
            rows[r].remove(num)
            cols[c].remove(num)
            boxes[box_index].remove(num)
            if backtrack(index + 1):                     # ë‹¤ìŒ ë¹ˆ ì¹¸ì„ ì±„ìš°ê¸° ìœ„í•´ ì¬ê·€ í˜¸ì¶œ, falseê°€ ë°˜í™˜ë˜ ë°‘ì˜ ë³µêµ¬ ì½”ë“œ ì‹¤í–‰ë¨
                return True
            board[r][c] = 0                              # ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš° ìˆ«ìë¥¼ ì œê±°í•˜ê³  ìƒíƒœë¥¼ ë³µêµ¬
            rows[r].add(num)
            cols[c].add(num)
            boxes[box_index].add(num)
        return False

    backtrack(0)
    return board

def print_board(board):
    for row in board:
        print(" ".join(map(str, row)))

if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().strip().split()
    board = []
    for i in range(0, 81, 9):
        board.append(list(map(int, data[i:i+9])))

    solve_sudoku(board)
    print_board(board)






def calculate(a, b, operator):
    if operator == 0:  # ë§ì…ˆ
        return a + b
    elif operator == 1:  # ëº„ì…ˆ
        return a - b
    elif operator == 2:  # ê³±ì…ˆ
        return a * b
    elif operator == 3:  # ë‚˜ëˆ—ì…ˆ
        if a < 0:
            return -(-a // b)
        return a // b

def backtrack(index, current_value):
    global max_value, min_value, operators

    # ëª¨ë“  ìˆ«ìì™€ ì—°ì‚°ìë¥¼ ì‚¬ìš©í–ˆì„ ë•Œ ìµœëŒ“ê°’ê³¼ ìµœì†Ÿê°’ì„ ê°±ì‹ 
    if index == N - 1:
        max_value = max(max_value, current_value)
        min_value = min(min_value, current_value)
        return
    # backtrack í•¨ìˆ˜ ë‚´ì—ì„œ returnì´ ê°±ì‹  íŒŒíŠ¸ì—ë§Œ ìˆëŠ” ê²ƒì€ ë°±íŠ¸ë˜í‚¹ì˜ íš¨ìœ¨ì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•œ ì¤‘ìš”í•œ ë¶€ë¶„ì…ë‹ˆë‹¤.

    # ê°€ëŠ¥í•œ ëª¨ë“  ì—°ì‚°ìë¥¼ ì‹œë„
    for i in range(4):
        if operators[i] > 0:
            # ì—°ì‚°ì ì‚¬ìš©
            operators[i] -= 1
            next_value = calculate(current_value, numbers[index + 1], i)
            backtrack(index + 1, next_value)
            # ìƒíƒœ ë³µêµ¬
            operators[i] += 1

def solve(N, numbers, operators):
    global max_value, min_value
    max_value = -float('inf')
    min_value = float('inf')
    backtrack(0, numbers[0])
    return max_value, min_value

if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().strip().split()

    N = int(data[0])
    numbers = list(map(int, data[1:N+1]))
    operators = list(map(int, data[N+1:]))

    max_val, min_val = solve(N, numbers, operators)
    print(max_val)
    print(min_val)

"""
ê°€ëŠ¥í•œ ëª¨ë“  ì—°ì‚°ì ì¡°í•©ì˜ ìˆ˜: ğ‘‚(ğ‘â‹…4ğ‘)ë¡œ í‘œí˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ê°€ëŠ¥í•œ ëª¨ë“  ì—°ì‚°ì ì¡°í•©ì˜ ìˆ˜ëŠ” 4^10 =1,048,576
ê° ì¡°í•©ë§ˆë‹¤ ìµœëŒ€ 10ê°œì˜ ì—°ì‚°ì´ í•„ìš”
ì´ ì—°ì‚° ìˆ˜ëŠ” 11â‹…(4^10)=11,534,336
"""
