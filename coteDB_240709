def check_cards(n_cards, m_queries):
    # ìƒê·¼ì´ê°€ ê°€ì§€ê³  ìˆëŠ” ìˆ«ì ì¹´ë“œë¥¼ setìœ¼ë¡œ ì €ì¥
    card_set = set(n_cards)
    
    # ì¡°íšŒí•  ìˆ«ìë“¤ì´ card_setì— ìˆëŠ”ì§€ í™•ì¸
    result = [1 if query in card_set else 0 for query in m_queries]
    
    # ê²°ê³¼ ì¶œë ¥
    return result

# ì…ë ¥ ë°›ê¸°
N = int(input().strip())
n_cards = list(map(int, input().strip().split()))
M = int(input().strip())
m_queries = list(map(int, input().strip().split()))

# ì¹´ë“œ ì²´í¬ í›„ ê²°ê³¼ ì¶œë ¥
result = check_cards(n_cards, m_queries)
print(' '.join(map(str, result)))
"""
n_cardsë¥¼ setìœ¼ë¡œ ë³€í™˜í•œ ì´ìœ ëŠ” íŠ¹ì • ìˆ«ìê°€ ìƒê·¼ì´ì˜ ì¹´ë“œì— ìˆëŠ”ì§€ ë¹ ë¥´ê²Œ í™•ì¸í•˜ê¸° ìœ„í•´ì„œì…ë‹ˆë‹¤. ë¦¬ìŠ¤íŠ¸ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ë©´ ê° ìˆ«ìë¥¼ í™•ì¸í•  ë•Œë§ˆë‹¤ 
ë¦¬ìŠ¤íŠ¸ ì „ì²´ë¥¼ ê²€ìƒ‰í•´ì•¼ í•˜ë¯€ë¡œ ì‹œê°„ ë³µì¡ë„ê°€ ğ‘‚(ğ‘€Ã—ğ‘)ì´ ë©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ setì„ ì‚¬ìš©í•˜ë©´ ê° ìˆ«ìì— ëŒ€í•´ ìƒìˆ˜ ì‹œê°„ 
ğ‘‚(1) ì•ˆì— í™•ì¸í•  ìˆ˜ ìˆì–´ ì „ì²´ ì‹œê°„ ë³µì¡ë„ê°€ ğ‘‚(ğ‘€)ë¡œ ì¤„ì–´ë“­ë‹ˆë‹¤.

ë§Œì•½ n_cardsë¥¼ setìœ¼ë¡œ ë³€í™˜í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´, ê° ì¡°íšŒí•  ìˆ«ìì— ëŒ€í•´ n_cards ë¦¬ìŠ¤íŠ¸ ì „ì²´ë¥¼ ê²€ìƒ‰í•´ì•¼ í•˜ë¯€ë¡œ forë¬¸ì„ 2ê°œ ì¨ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
ì´ë ‡ê²Œ í•˜ë©´ ì‹œê°„ ë³µì¡ë„ê°€ O(MÃ—N)ê°€ ë˜ì–´ ì„±ëŠ¥ì´ ì €í•˜ë©ë‹ˆë‹¤.
"""




def count_included_strings(S, queries):
    # ì§‘í•© Së¥¼ setìœ¼ë¡œ ë³€í™˜
    string_set = set(S)
    
    # í¬í•¨ëœ ë¬¸ìì—´ ê°œìˆ˜ë¥¼ ì„¸ê¸°
    count = sum(1 for query in queries if query in string_set)
    
    return count

# ì…ë ¥ ë°›ê¸°
N, M = map(int, input().strip().split())
S = [input().strip() for _ in range(N)]
queries = [input().strip() for _ in range(M)]

# í¬í•¨ëœ ë¬¸ìì—´ ê°œìˆ˜ ì¶œë ¥
result = count_included_strings(S, queries)
print(result)
"""
 queriesëŠ” ë¦¬ìŠ¤íŠ¸ì´ê³ , string_setëŠ” setì´ì§€ë§Œ for query in queries if query in string_setë¼ëŠ” ì¡°ê±´ë¬¸ì€ 
ë¦¬ìŠ¤íŠ¸ì˜ ê° ìš”ì†Œê°€ setì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ë¥¼ ì˜ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” Pythonì—ì„œ ì§€ì›í•˜ëŠ” ì •ìƒì ì¸ ë¹„êµ ë°©ë²•ì…ë‹ˆë‹¤.

setì˜ ì¡°íšŒ ì‹œê°„ ë³µì¡ë„ëŠ” í‰ê· ì ìœ¼ë¡œ O(1)ì´ê¸° ë•Œë¬¸ì—, ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒë³´ë‹¤ í›¨ì”¬ ë¹ ë¥´ê²Œ íŠ¹ì • ë¬¸ìì—´ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
1. ì§‘í•© Së¥¼ setìœ¼ë¡œ ë³€í™˜ :
SëŠ” Nê°œì˜ ë¬¸ìì—´ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤. ë¦¬ìŠ¤íŠ¸ Së¥¼ setìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì€ O(N)ì…ë‹ˆë‹¤.

2. Mê°œì˜ ë¬¸ìì—´ì„ ê²€ìƒ‰:
ê° ë¬¸ìì—´ì„ setì—ì„œ ì¡°íšŒí•˜ëŠ” ì‹œê°„ ë³µì¡ë„ëŠ” O(1)ì…ë‹ˆë‹¤. Mê°œì˜ ë¬¸ìì—´ì„ ì¡°íšŒí•˜ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì€ O(M)ì…ë‹ˆë‹¤.

ë”°ë¼ì„œ ì „ì²´ ì‹œê°„ ë³µì¡ë„ëŠ” Nê°œì˜ ì´ˆê¸° ë³€í™˜ê³¼ Mê°œì˜ ì¡°íšŒë¡œ êµ¬ì„±ë˜ì–´ O(N+M)ë‹ˆë‹¤
"""




def find_current_employees(log_entries):
    current_employees = set()
    
    for entry in log_entries:
        name, action = entry.split()
        if action == "enter":
            current_employees.add(name)
        elif action == "leave":
            current_employees.remove(name)
    
    return sorted(current_employees, reverse=True)

# ì…ë ¥ ë°›ê¸°
n = int(input().strip())
log_entries = [input().strip() for _ in range(n)]

# í˜„ì¬ íšŒì‚¬ì— ìˆëŠ” ì‚¬ëŒë“¤ ì¶œë ¥
current_employees = find_current_employees(log_entries)
for employee in current_employees:
    print(employee)
"""
1.
log_entries = [
    "Baha enter",
    "Askar enter",
    "Baha leave",
    "Artem enter"
]
ê° ìš”ì†ŒëŠ” ë¡œê·¸ ê¸°ë¡ì˜ í•œ ì¤„ë¡œ, "ì´ë¦„ ë™ì‘" í˜•ì‹ì˜ ë¬¸ìì—´ì…ë‹ˆë‹¤. ì´ ë¦¬ìŠ¤íŠ¸ëŠ” find_current_employees í•¨ìˆ˜ì— ì „ë‹¬ë˜ì–´ ê° ë¡œê·¸ ê¸°ë¡ì„ ì²˜ë¦¬í•˜ê²Œ ë©ë‹ˆë‹¤.

2.
entry = "Baha enter"
entry = entry.strip()  # "Baha enter" (ë³€í™” ì—†ìŒ)
name, action = entry.split()  # name = "Baha", action = "enter"
trip()ì€ ë¬¸ìì—´ ì–‘ìª½ ëì˜ ê³µë°± ë¬¸ìë¥¼ ì œê±°í•  ë¿, ë¬¸ìì—´ ë‚´ë¶€ì˜ ê³µë°±ì—ëŠ” ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.
"""




def pokemon_master(N, M, pokemon_list, questions):
    name_to_number = {}
    number_to_name = {}

    for i in range(1, N + 1):
        name = pokemon_list[i - 1]
        name_to_number[name] = i
        number_to_name[i] = name

    results = []
    for question in questions:
        if question.isdigit():
            number = int(question)
            results.append(number_to_name[number])
        else:
            results.append(str(name_to_number[question]))

    return results

# ì…ë ¥ ë°›ê¸°
N, M = map(int, input().strip().split())
pokemon_list = [input().strip() for _ in range(N)]
questions = [input().strip() for _ in range(M)]

# ê²°ê³¼ ì¶œë ¥
results = pokemon_master(N, M, pokemon_list, questions)
for result in results:
    print(result)
"""
name_to_numberëŠ” ë¬¸ìì—´(í¬ì¼“ëª¬ ì´ë¦„)ì„ í‚¤ë¡œ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ í¬ì¼“ëª¬ì˜ ë²ˆí˜¸ì— ì ‘ê·¼í•˜ëŠ” ì‚¬ì „ì…ë‹ˆë‹¤.
ë°˜ë©´ number_to_nameëŠ” ìˆ«ì(í¬ì¼“ëª¬ ë²ˆí˜¸)ë¥¼ í‚¤ë¡œ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ í¬ì¼“ëª¬ì˜ ì´ë¦„ì— ì ‘ê·¼í•˜ëŠ” ì‚¬ì „ì…ë‹ˆë‹¤.

# ì˜ˆì œ ë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‚¬ì „ë“¤ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
name_to_number = {
    "Bulbasaur": 1,
    "Ivysaur": 2,
    "Venusaur": 3,
    # ... (ì¤‘ëµ)
    "Raichu": 26
}

number_to_name = {
    1: "Bulbasaur",
    2: "Ivysaur",
    3: "Venusaur",
    # ... (ì¤‘ëµ)
    26: "Raichu"
}

# í¬ì¼“ëª¬ ì´ë¦„ìœ¼ë¡œ ë²ˆí˜¸ë¥¼ ì°¾ëŠ” ì˜ˆì œ
pokemon_name = "Venusaur"
pokemon_number = name_to_number[pokemon_name]  # 3

# í¬ì¼“ëª¬ ë²ˆí˜¸ë¡œ ì´ë¦„ì„ ì°¾ëŠ” ì˜ˆì œ
pokemon_number = 3
pokemon_name = number_to_name[pokemon_number]  # "Venusaur"
"""
isdigit() ë©”ì„œë“œëŠ” ë¬¸ìì—´ì´ ëª¨ë‘ ìˆ«ìë¡œë§Œ ì´ë£¨ì–´ì ¸ ìˆëŠ”ì§€ë¥¼ íŒë‹¨í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤. ë§Œì•½ ë¬¸ìì—´ì´ ìˆ«ìë¡œë§Œ êµ¬ì„±ë˜ì–´ ìˆë‹¤ë©´ Trueë¥¼ ë°˜í™˜í•˜ê³ , ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ Falseë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
"""




from collections import Counter

def count_cards(n_cards, m_queries):
    card_counter = Counter(n_cards)
    
    results = [card_counter[query] for query in m_queries]
    
    return results

# ì…ë ¥ ë°›ê¸°
N = int(input().strip())
n_cards = list(map(int, input().strip().split()))
M = int(input().strip())
m_queries = list(map(int, input().strip().split()))

# ìˆ«ì ì¹´ë“œ ê°œìˆ˜ ì„¸ê¸° í›„ ê²°ê³¼ ì¶œë ¥
results = count_cards(n_cards, m_queries)
print(' '.join(map(str, results)))

"""
n_cards = [6, 3, 2, 10, 10, 10, -10, -10, 7, 3]
card_counter = Counter(n_cards)

print(card_counter) # Counter({10: 3, 3: 2, -10: 2, 6: 1, 2: 1, 7: 1})
print(type(card_counter))  # <class 'collections.Counter'>

CounterëŠ” ê° ìš”ì†Œë¥¼ í‚¤ë¡œ ì‚¬ìš©í•˜ê³ , ê·¸ ìš”ì†Œê°€ ë¦¬ìŠ¤íŠ¸ì—ì„œ ëª‡ ë²ˆ ë“±ì¥í–ˆëŠ”ì§€ë¥¼ ê°’ìœ¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤.
card_counterì˜ ìë£Œí˜•ì€ collections.Counter ê°ì²´ì…ë‹ˆë‹¤. 
ì´ ê°ì²´ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ dictì™€ ìœ ì‚¬í•˜ì§€ë§Œ, ìš”ì†Œì˜ ê°œìˆ˜ë¥¼ ìë™ìœ¼ë¡œ ì„¸ì–´ì£¼ëŠ” ì¶”ê°€ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.

Nê³¼ Mì€ ì…ë ¥ í˜•ì‹ì— í¬í•¨ëœ ì •ë³´ë¡œ, ìƒê·¼ì´ê°€ ê°€ì§€ê³  ìˆëŠ” ìˆ«ì ì¹´ë“œì˜ ê°œìˆ˜ì™€ ë¬¸ì œë¡œ ì£¼ì–´ì§„ ìˆ«ìì˜ ê°œìˆ˜ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. 
ê·¸ëŸ¬ë‚˜ ì½”ë“œì˜ ì‹¤ì œ ë¡œì§ì—ì„œëŠ” Nê³¼ Mì´ ì§ì ‘ì ìœ¼ë¡œ ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì…ë ¥ í˜•ì‹ ìƒ ë°˜ë“œì‹œ í¬í•¨ë˜ì–´ì•¼ í•  ë¿ì…ë‹ˆë‹¤. 
"""





def find_heard_and_seen(unheard_list, unseen_list):
    unheard_set = set(unheard_list)
    unseen_set = set(unseen_list)
    
    intersection = unheard_set & unseen_set
    result_list = sorted(intersection)
    
    return result_list

# ì…ë ¥ ë°›ê¸°
N, M = map(int, input().strip().split())
unheard_list = [input().strip() for _ in range(N)]
unseen_list = [input().strip() for _ in range(M)]

# ë“£ë³´ì¡ ëª…ë‹¨ êµ¬í•˜ê¸°
result_list = find_heard_and_seen(unheard_list, unseen_list)

# ê²°ê³¼ ì¶œë ¥
print(len(result_list))
for name in result_list:
    print(name)

"""
A_sizeì™€ B_sizeëŠ” ì…ë ¥ í˜•ì‹ìƒ í•„ìš”í•˜ì§€ë§Œ, ì½”ë“œ ë¡œì§ì—ì„œëŠ” ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
ì…ë ¥ ë°ì´í„°ì˜ í˜•ì‹ì„ ë§ì¶”ê¸° ìœ„í•´ í¬í•¨ëœ ê²ƒì…ë‹ˆë‹¤.
ì˜ˆì œ ì…ë ¥
3 5
1 2 4
2 3 4 5 6
"""




def count_unique_substrings(S):
    substrings = set()
    
    # ëª¨ë“  ë¶€ë¶„ ë¬¸ìì—´ì„ ìƒì„±í•˜ì—¬ setì— ì¶”ê°€
    for i in range(len(S)):
        for j in range(i + 1, len(S) + 1):
            substrings.add(S[i:j])
    
    return len(substrings)

# ì…ë ¥ ë°›ê¸°
S = input().strip()

# ì„œë¡œ ë‹¤ë¥¸ ë¶€ë¶„ ë¬¸ìì—´ì˜ ê°œìˆ˜ ì¶œë ¥
result = count_unique_substrings(S)
print(result)

"""
iëŠ” ë¶€ë¶„ ë¬¸ìì—´ì˜ ì‹œì‘ ì¸ë±ìŠ¤ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
jëŠ” ë¶€ë¶„ ë¬¸ìì—´ì˜ ë ì¸ë±ìŠ¤ë¥¼ ë‚˜íƒ€ë‚´ë©°, S[i:j]ëŠ” ì‹œì‘ ì¸ë±ìŠ¤ ië¶€í„° ë ì¸ë±ìŠ¤ j-1ê¹Œì§€ì˜ ë¶€ë¶„ ë¬¸ìì—´ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

i = 0
j = 1: S[0:1] = "a"
j = 2: S[0:2] = "ab"
j = 3: S[0:3] = "aba"
j = 4: S[0:4] = "abab"
j = 5: S[0:5] = "ababc"
i = 1
j = 2: S[1:2] = "b"
j = 3: S[1:3] = "ba"
j = 4: S[1:4] = "bab"
j = 5: S[1:5] = "babc"
i = 2
j = 3: S[2:3] = "a"
j = 4: S[2:4] = "ab"
j = 5: S[2:5] = "abc"
i = 3
j = 4: S[3:4] = "b"
j = 5: S[3:5] = "bc"
i = 4
j = 5: S[4:5] = "c"

S[i:j]ëŠ” ë¬¸ìì—´ Sì—ì„œ ië²ˆì§¸ ì¸ë±ìŠ¤ë¶€í„° j-1ë²ˆì§¸ ì¸ë±ìŠ¤ê¹Œì§€ì˜ ì—°ì†ëœ ë¶€ë¶„ ë¬¸ìì—´ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.
íŒŒì´ì¬ì—ì„œ ë¬¸ìì—´ ìŠ¬ë¼ì´ì‹±ì€ S[start:end] í˜•íƒœë¡œ, start ì¸ë±ìŠ¤ì—ì„œ ì‹œì‘í•˜ì—¬ end-1 ì¸ë±ìŠ¤ê¹Œì§€ì˜ ë¶€ë¶„ ë¬¸ìì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
"""




import math

def find_lcm(a, b):
    return abs(a * b) // math.gcd(a, b)

# ì…ë ¥ ë°›ê¸°
T = int(input().strip())
test_cases = [tuple(map(int, input().strip().split())) for _ in range(T)]

# ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì— ëŒ€í•´ ìµœì†Œê³µë°°ìˆ˜ êµ¬í•˜ê¸°
results = [find_lcm(a, b) for a, b in test_cases]

# ê²°ê³¼ ì¶œë ¥
for result in results:
    print(result)

"""
Tê°œì˜ ì¤„ì—ì„œ ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë§ˆë‹¤ ë‘ ìˆ˜ Aì™€ Bë¥¼ ì…ë ¥ë°›ì•„ test_cases ë¦¬ìŠ¤íŠ¸ì— ì €ì¥í•©ë‹ˆë‹¤.
test_cases ë¦¬ìŠ¤íŠ¸ ì•ˆì— íŠœí”Œì˜ í˜•íƒœë¡œ ì •ìˆ˜ë“¤ì„ ì…ë ¥í•˜ëŠ” ì´ìœ ëŠ” ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë§ˆë‹¤ ë‘ ê°œì˜ ì •ìˆ˜, ì¦‰ Aì™€ Bê°€ ì£¼ì–´ì§€ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤ : ë°ì´í„° êµ¬ì¡°ì˜ ëª…í™•ì„±, í¸ë¦¬í•œ ì ‘ê·¼

forë¬¸ì„ ì‚¬ìš©í•  ë•Œ, test_cases ë¦¬ìŠ¤íŠ¸ì— íŠœí”Œì˜ í˜•íƒœë¡œ ë°ì´í„°ê°€ ì €ì¥ë˜ì–´ ìˆê¸° ë•Œë¬¸ì— ê° íŠœí”Œì˜ ì²« ë²ˆì§¸ ìš”ì†Œê°€ aì—, ë‘ ë²ˆì§¸ ìš”ì†Œê°€ bì— ëŒ€ì…ë©ë‹ˆë‹¤.
ì´ ë°©ì‹ì€ íŒŒì´ì¬ì˜ ì–¸íŒ¨í‚¹(unpacking) ê¸°ëŠ¥ì„ ì‚¬ìš©í•œ ê²ƒì…ë‹ˆë‹¤. test_cases ë¦¬ìŠ¤íŠ¸ì˜ ê° ìš”ì†Œê°€ (a, b) í˜•íƒœì˜ íŠœí”Œì´ê¸° ë•Œë¬¸ì—, ê° íŠœí”Œì´ ìˆœì°¨ì ìœ¼ë¡œ aì™€ b ë³€ìˆ˜ì— ì–¸íŒ¨í‚¹ë˜ì–´ ëŒ€ì…ë©ë‹ˆë‹¤.
"""




def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def find_lcm(a, b):
    return abs(a * b) // gcd(a, b)

# ì…ë ¥ ë°›ê¸°
a, b = map(int, input().strip().split())

# ìµœì†Œê³µë°°ìˆ˜ êµ¬í•˜ê¸°
result = find_lcm(a, b)

# ê²°ê³¼ ì¶œë ¥
print(result)




def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def add_fractions(A, B, C, D):
    numerator = A * D + C * B
    denominator = B * D
    common_divisor = gcd(numerator, denominator)
    
    # ê¸°ì•½ë¶„ìˆ˜ë¡œ ë§Œë“¤ê¸° ìœ„í•´ ì•½ë¶„
    numerator //= common_divisor
    denominator //= common_divisor
    
    return numerator, denominator

# ì…ë ¥ ë°›ê¸°
A, B = map(int, input().strip().split())
C, D = map(int, input().strip().split())

# ë¶„ìˆ˜ì˜ í•© êµ¬í•˜ê¸°
result_numerator, result_denominator = add_fractions(A, B, C, D)

# ê²°ê³¼ ì¶œë ¥
print(result_numerator, result_denominator)




import math
from functools import reduce

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def find_gcd_of_list(lst):
    return reduce(gcd, lst)

# ì…ë ¥ ë°›ê¸°
N = int(input().strip())
tree_positions = [int(input().strip()) for _ in range(N)]

# ê° ê°€ë¡œìˆ˜ ì‚¬ì´ì˜ ê°„ê²© ê³„ì‚°
intervals = [tree_positions[i+1] - tree_positions[i] for i in range(N-1)]

# ê°„ê²©ë“¤ì˜ GCD êµ¬í•˜ê¸°
gcd_of_intervals = find_gcd_of_list(intervals)

# í•„ìš”í•œ ê°€ë¡œìˆ˜ì˜ ìˆ˜ ê³„ì‚°
trees_needed = sum((interval // gcd_of_intervals) - 1 for interval in intervals)

# ê²°ê³¼ ì¶œë ¥
print(trees_needed)

"""
reduceë¥¼ ì‚¬ìš©í•˜ì—¬ ë¦¬ìŠ¤íŠ¸ì˜ ëª¨ë“  ìš”ì†Œì— ëŒ€í•´ GCDë¥¼ êµ¬í•©ë‹ˆë‹¤.
"""




import sys
import math

def is_prime(num):
    if num <= 1:
        return False
    if num <= 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    i = 5
    while i * i <= num:
        if num % i == 0 or num % (i + 2) == 0:
            return False
        i += 6
    return True

def next_prime(n):
    if n <= 1:
        return 2
    prime = n
    found = False
    while not found:
        if is_prime(prime):
            found = True
        else:
            prime += 1
    return prime

# ì…ë ¥ ë°›ê¸°
input = sys.stdin.read
data = input().strip().split()

T = int(data[0])
results = []

for i in range(1, T + 1):
    n = int(data[i])
    results.append(next_prime(n))

# ê²°ê³¼ ì¶œë ¥
for result in results:
    print(result)

"""
ë¬¸ì œ
ì •ìˆ˜ n(0 â‰¤ n â‰¤ 4*10^9)ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, në³´ë‹¤ í¬ê±°ë‚˜ ê°™ì€ ì†Œìˆ˜ ì¤‘ ê°€ì¥ ì‘ì€ ì†Œìˆ˜ ì°¾ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

ì†Œìˆ˜ë¥¼ í™•ì¸í•˜ê¸° ìœ„í•´ ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì²´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆì§€ë§Œ, ë¬¸ì œì˜ ë²”ìœ„ê°€ ë§¤ìš° í¬ë¯€ë¡œ ì§ì ‘ ì†Œìˆ˜ íŒë³„ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì í•©í•©ë‹ˆë‹¤.
2ì™€ 3ì€ ì˜ˆì™¸ì ìœ¼ë¡œ ë¨¼ì € ì²˜ë¦¬í•©ë‹ˆë‹¤. ê·¸ ì™¸ì˜ ìˆ«ìëŠ” 5ë¶€í„° ì‹œì‘í•´ 6kÂ±1 í˜•íƒœë¡œ ì¦ê°€í•˜ëŠ” ìˆ«ìë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§€ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

6k Â± 1 í˜•íƒœì˜ ìˆ«ìëŠ” ì†Œìˆ˜ê°€ ë  ê°€ëŠ¥ì„±ì´ ìˆëŠ” ìˆ«ìë“¤ì…ë‹ˆë‹¤. ì´ëŸ° í˜•íƒœì˜ ìˆ«ìê°€ ì†Œìˆ˜ê°€ ì•„ë‹Œ ê²½ìš°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ í•„ìš”í•©ë‹ˆë‹¤. 
ì´ ë¬¸ì œëŠ” is_prime í•¨ìˆ˜ ë‚´ì—ì„œ ì´ë¯¸ ì²˜ë¦¬ë˜ê³  ìˆìŠµë‹ˆë‹¤.

ì†Œìˆ˜ íŒë³„ì„ í•  ë•Œ ìµœëŒ€ sqrt(num)ê¹Œì§€ë§Œ í™•ì¸í•˜ë©´ ë©ë‹ˆë‹¤. 
ê·¸ ì´ìœ ëŠ”, ë§Œì•½ numì´ ië¡œ ë‚˜ëˆ„ì–´ë–¨ì–´ì§„ë‹¤ë©´, num = i * jë¥¼ ë§Œì¡±í•˜ëŠ” ì–´ë–¤ jê°€ ì¡´ì¬í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œ iì™€ j ì¤‘ í•˜ë‚˜ëŠ” ë°˜ë“œì‹œ sqrt(num) ì´í•˜ì…ë‹ˆë‹¤. 

    not_found = True
    while not_found:
        if is_prime(prime):
            not_found = False
     â–² ì´ëŸ° ì‹ìœ¼ë¡œ í•  ìˆ˜ë„ ìˆë‹¤.

i = 7
while i * i <= num:
    if num % (i - 2) == 0 or num % i == 0:
        return False
ì™€ ê°™ì´ í•˜ë©´7 * 7 > 25ì´ë¯€ë¡œ whileë¬¸ì˜ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•Šì•„ ë£¨í”„ê°€ ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
ë”°ë¼ì„œ 25ëŠ” ì†Œìˆ˜ë¡œ ì˜ëª» íŒë³„ë  ìˆ˜ ìˆë‹¤. ì¡°ê±´ë¬¸ì´ ì• ì´ˆì— ì„±ë¦½í•˜ì§€ ì•Šì•„ì„œ 
5ì™€ 7, 11ê³¼ 13, 17ê³¼ 19 ë“±ì˜ íŒ¨í„´ì„ ê²€ì‚¬í•˜ì§€ ì•Šê²Œ ë˜ì–´ ì •í™•í•œ ê²°ê³¼ë¥¼ ë³´ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
"""




def sieve_of_eratosthenes(M, N):
    # Nê¹Œì§€ì˜ ì†Œìˆ˜ íŒë³„ì„ ìœ„í•œ ë°°ì—´
    is_prime = [True] * (N + 1)
    is_prime[0] = is_prime[1] = False  # 0ê³¼ 1ì€ ì†Œìˆ˜ê°€ ì•„ë‹˜
    
    p = 2
    while p * p <= N:
        if is_prime[p]:
            for i in range(p * p, N + 1, p):
                is_prime[i] = False # is_prime[p]ê°€ Trueì´ë©´, pì˜ ë°°ìˆ˜ë“¤ì„ ëª¨ë‘ Falseë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
        p += 1
    
    # M ì´ìƒ N ì´í•˜ì˜ ì†Œìˆ˜ ì¶œë ¥
    for num in range(M, N + 1):
        if is_prime[num]:
            print(num)

# ì…ë ¥ ë°›ê¸°
M, N = map(int, input().strip().split())

# ì†Œìˆ˜ ì¶œë ¥
sieve_of_eratosthenes(M, N)

"""
p*pë¥¼ ì‹œì‘ì ìœ¼ë¡œ ì„¤ì •í•œ ì´ìœ ëŠ”, ê·¸ ì´ì „ì˜ ë°°ìˆ˜ë“¤ì€ ì´ë¯¸ ë‹¤ë¥¸ ì†Œìˆ˜ë“¤ì— ì˜í•´ ì²˜ë¦¬ë˜ì—ˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì²´ ì•Œê³ ë¦¬ì¦˜ì˜ í•µì‹¬ ì•„ì´ë””ì–´ëŠ” pê°€ ì†Œìˆ˜ì¼ ë•Œ, pì˜ ë°°ìˆ˜ë“¤ì„ ì œê±°í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.
pì˜ ë°°ìˆ˜ ì¤‘ p*2, p*3, ... , p*(p-1)ëŠ” ì´ë¯¸ ì´ì „ ì†Œìˆ˜ë“¤ì— ì˜í•´ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ p=5ì¼ ë•Œ, p*2 = 10, p*3 = 15, p*4 = 20ì€ ì´ì „ì˜ ì†Œìˆ˜ì¸ p=2, 3ì— ì˜í•´ ì´ë¯¸ ë‹¤ ì†Œê±°ë¨.
"""




def sieve_of_eratosthenes(limit):
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False
    
    p = 2
    while p * p <= limit:
        if is_prime[p]:
            for i in range(p * p, limit + 1, p):
                is_prime[i] = False
        p += 1
    return is_prime

def count_primes_in_range(n, is_prime):
    count = 0
    for num in range(n + 1, 2 * n + 1):
        if is_prime[num]:
            count += 1
    return count

# ë¯¸ë¦¬ 2 * 123456ê¹Œì§€ì˜ ì†Œìˆ˜ë¥¼ êµ¬í•´ ë†“ìŒ
limit = 2 * 123456
is_prime = sieve_of_eratosthenes(limit)

# ì…ë ¥ ë°›ê¸° ë° ì²˜ë¦¬
import sys
input = sys.stdin.read
data = input().strip().split()

results = []
for n in map(int, data):
    if n == 0:
        break
    results.append(count_primes_in_range(n, is_prime))

# ê²°ê³¼ ì¶œë ¥
for result in results:
    print(result)

"""
ì œí•œ : 1 â‰¤ n â‰¤ 123,456

4. ì…ë ¥ ì²˜ë¦¬ ë° ê²°ê³¼ ì¶œë ¥:
í‘œì¤€ ì…ë ¥ìœ¼ë¡œ ì—¬ëŸ¬ ê°œì˜ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ ì…ë ¥ë°›ìŠµë‹ˆë‹¤.
ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì— ëŒ€í•´ ë²”ìœ„ ë‚´ì˜ ì†Œìˆ˜ ê°œìˆ˜ë¥¼ ì„¸ì–´ results ë¦¬ìŠ¤íŠ¸ì— ì €ì¥í•©ë‹ˆë‹¤.
ë§ˆì§€ë§‰ì— results ë¦¬ìŠ¤íŠ¸ì˜ ê°’ì„ ìˆœì°¨ì ìœ¼ë¡œ ì¶œë ¥í•©ë‹ˆë‹¤.

1. ì…ë ¥ ë°›ê¸°:
input = sys.stdin.readë¥¼ ì‚¬ìš©í•˜ì—¬ í‘œì¤€ ì…ë ¥ì—ì„œ ëª¨ë“  ë°ì´í„°ë¥¼ í•œ ë²ˆì— ì½ì–´ì˜µë‹ˆë‹¤.
data = input().strip().split()ë¥¼ í†µí•´ ì…ë ¥ëœ ë°ì´í„°ë¥¼ ê³µë°± ê¸°ì¤€ìœ¼ë¡œ ë¶„ë¦¬í•˜ì—¬ ë¦¬ìŠ¤íŠ¸ dataì— ì €ì¥í•©ë‹ˆë‹¤.

2. ê²°ê³¼ ê³„ì‚° ë° ì €ì¥:
for n in map(int, data) ë£¨í”„ëŠ” data ë¦¬ìŠ¤íŠ¸ì˜ ê° ìš”ì†Œë¥¼ ì •ìˆ˜ë¡œ ë³€í™˜í•˜ì—¬ ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
ê° nì— ëŒ€í•´ count_primes_in_range(n, is_prime)ë¥¼ í˜¸ì¶œí•˜ì—¬ ê²°ê³¼ë¥¼ ê³„ì‚°í•˜ê³ , results ë¦¬ìŠ¤íŠ¸ì— ì €ì¥í•©ë‹ˆë‹¤.
nì´ 0ì´ë©´ ë£¨í”„ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.

data ë¦¬ìŠ¤íŠ¸ëŠ” sys.stdin.readë¥¼ í†µí•´ ëª¨ë“  ì…ë ¥ì„ í•œ ë²ˆì— ì½ì–´ì˜µë‹ˆë‹¤. ë”°ë¼ì„œ, for ë£¨í”„ê°€ ì‹¤í–‰ë  ë•ŒëŠ” ì´ë¯¸ ëª¨ë“  ì…ë ¥ì´ dataì— ì €ì¥ëœ ìƒíƒœì…ë‹ˆë‹¤.
ì…ë ¥ì„ í•œ ë²ˆì— ëª¨ë‘ ë°›ê¸° ë•Œë¬¸ì—, ì…ë ¥ì´ ì¶”ê°€ë¡œ ê°±ì‹ ë  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤.
data ë¦¬ìŠ¤íŠ¸ì—ëŠ” 0ì´ ì¶”ê°€ëœ ì´í›„ì—ë„ ê³„ì†ì ìœ¼ë¡œ ì •ìˆ˜ê°€ í¬í•¨ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ for ë£¨í”„ì—ì„œ 0ì„ ì¸ì‹í•˜ë©´ break ë¬¸ì„ í†µí•´ ë£¨í”„ê°€ ì¢…ë£Œë©ë‹ˆë‹¤.

í‘œì¤€ ì…ë ¥ì„ ì¤‘ë‹¨í•˜ëŠ” ë°©ë²•ìœ¼ë¡œëŠ” EOF (End Of File) ì‹ í˜¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤.
ì´ëŠ” ì¼ë°˜ì ìœ¼ë¡œ í„°ë¯¸ë„ì´ë‚˜ ì½˜ì†”ì—ì„œ Ctrl + D (ìœ ë‹‰ìŠ¤ ê¸°ë°˜ ì‹œìŠ¤í…œ) ë˜ëŠ” Ctrl + Z (ìœˆë„ìš°) í‚¤ ì¡°í•©ì„ ì‚¬ìš©í•˜ì—¬ ì…ë ¥ì„ ì¢…ë£Œí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

# ì…ë ¥ ë°›ê¸° ë° ì²˜ë¦¬
results = []
try:
    while True:
        line = input().strip()
        if line == "0":
            break
        n = int(line)
        results.append(count_primes_in_range(n, is_prime))
except EOFError:
    pass

# ê²°ê³¼ ì¶œë ¥
for result in results:
    print(result)
"""
